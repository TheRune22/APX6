# -*- coding: utf-8 -*-
"""APX handin 6.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Qn6-_ovCwPRJtm7yh53X_qdxLJxZZF4S

# Approximation Algorithms hand-in 6

Install the hyperloglog library and read data files
"""
from typing import Tuple

# !pip -q install hyperloglog
# !wget -q https://raw.githubusercontent.com/rasmus-pagh/apx/main/data/words_danish.txt -O words_danish.txt
# !wget -q https://raw.githubusercontent.com/rasmus-pagh/apx/main/data/words_english.txt -O words_english.txt

import hyperloglog
import copy
from tqdm import tqdm

"""The code below reads two lists of words from files and prints statistics using a hyperloglog sketch"""

def create_hll(filename, relative_error):
  hll = hyperloglog.HyperLogLog(relative_error)
  with open(filename, 'r') as f:
    for word in f:
      hll.add(word)
  return hll

relative_error = 0.01
# hll_danish = create_hll('words_danish.txt', relative_error)
# hll_english = create_hll('words_english.txt', relative_error)

# print(f'HLL reports about {len(hll_danish)} Danish words and {len(hll_english)} English words')

# hll_combined = copy.deepcopy(hll_english) # Create a copy of the HLL
# hll_combined.update(hll_danish) # Merge the other HLL into the combined one
# print(f'Combined the two languages have about {len(hll_combined)} words')

"""
Your task is to add code, or modify the code, to compute information about the number of distinct substrings in the two languages. 
For example, the word "pop" has 6 distinct substrings, namely "" (the empty string), "p", "o", "po", "op" and "pop". 
Note that "pp" is not a substring since the letters are not consecutive.
"""


def get_substrings(word: str):
    substrings = []
    for i in range(len(word)):
        for j in range(i, len(word)):
          substrings.append(word[i:j+1])
    return substrings


def create_substring_hll(filename, relative_error):
  hll = hyperloglog.HyperLogLog(relative_error)

  with open(filename, 'r') as f:
    lines = f.readlines()

    for word in tqdm(lines):
      for substring in get_substrings(word):
        hll.add(substring)

  return hll


hll_danish = create_substring_hll('words_danish.txt', relative_error)
hll_english = create_substring_hll('words_english.txt', relative_error)

hll_combined = copy.deepcopy(hll_english) # Create a copy of the HLL
hll_combined.update(hll_danish) # Merge the other HLL into the combined one


#%%


class BoundedInt:
    def __init__(self, tuple_val: Tuple[int, int, int]):
        self.tuple_val = tuple_val

    @property
    def lower_bound(self):
        return self.tuple_val[0]

    @property
    def value(self):
        return self.tuple_val[1]

    @property
    def upper_bound(self):
        return self.tuple_val[2]

    @property
    def relative_error(self):
        return ((self.value - self.lower_bound)/ self.value, (self.upper_bound - self.value) / self.value)

    def __add__(self, other):
        return BoundedInt((self.lower_bound + other.lower_bound, self.value + other.value, self.upper_bound + other.upper_bound))

    def __sub__(self, other):
        return BoundedInt((self.lower_bound - other.upper_bound, self.value - other.value, self.upper_bound - other.lower_bound))


def get_lower_bound(val, relative_error):
    return val * (1 - relative_error)


def get_upper_bound(val, relative_error):
    return val * (1 + relative_error)


def get_bounds(hll, relative_error):
    length = len(hll)
    return BoundedInt((get_lower_bound(length, relative_error), length, get_upper_bound(length, relative_error)))


def print_results(bounded_int: BoundedInt, name):
    print(f"\n{name}:")
    print(f"Approximate value: {bounded_int.value}")
    print(f"Bounds: ({bounded_int.lower_bound}, {bounded_int.upper_bound})")


danish_bounds = get_bounds(hll_danish, relative_error)
english_bounds = get_bounds(hll_english, relative_error)
union_bounds = get_bounds(hll_combined, relative_error)


#%%


"""
1.   Use a hyperloglog data structure with relative error 0.01 to compute upper and lower bounds on the number of distinct substrings in Danish
and English, respectively. You may assume that HLL is guaranteed to return a number with the stated relative error.
"""

print_results(danish_bounds, "Danish")
print_results(english_bounds, "English")


"""
2.   Based on the answer from 1), and a cardinality estimate for the union, give upper and lower bounds on the number of common substrings 
in the two languages.
"""

print_results(union_bounds, "union")

intersection_bounds = danish_bounds + english_bounds - union_bounds

print_results(intersection_bounds, "intersection")


"""
3.    Suppose that the intersection size is at least 1% of each of the two sets. How small relative error on the cardinality estimates 
would you need to estimate the number of common substrings up to a relative error of 10%? 
(NB! The implementation provided does not support very small relative errors.)
"""

